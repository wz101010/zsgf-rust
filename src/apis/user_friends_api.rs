/*
 * 用户全部 API 文档
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`user_common_interests`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UserCommonInterestsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`user_follow_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UserFollowUserError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`user_follower_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UserFollowerPutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`user_followers`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UserFollowersError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`user_following`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UserFollowingError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`user_friends_near_by`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UserFriendsNearByError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`user_mutual_followers`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UserMutualFollowersError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`user_mutual_followings`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UserMutualFollowingsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`user_profile_by_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UserProfileByIdError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`user_unfollow_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UserUnfollowUserError {
    UnknownValue(serde_json::Value),
}


/// 推荐有共同爱好的用户
pub async fn user_common_interests(configuration: &configuration::Configuration, app_key: &str, tag: Option<&str>, skip: Option<i32>, take: Option<i32>) -> Result<models::UserCommonInterestsResultApiResponse, Error<UserCommonInterestsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_app_key = app_key;
    let p_tag = tag;
    let p_skip = skip;
    let p_take = take;

    let uri_str = format!("{}/UserFriends/{appKey}/CommonInterests", configuration.base_path, appKey=crate::apis::urlencode(p_app_key));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_tag {
        req_builder = req_builder.query(&[("tag", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_skip {
        req_builder = req_builder.query(&[("skip", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_take {
        req_builder = req_builder.query(&[("take", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UserCommonInterestsResultApiResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UserCommonInterestsResultApiResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UserCommonInterestsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 关注指定用户
pub async fn user_follow_user(configuration: &configuration::Configuration, user_id: i64, app_key: &str) -> Result<models::BooleanApiResponse, Error<UserFollowUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_user_id = user_id;
    let p_app_key = app_key;

    let uri_str = format!("{}/UserFriends/{appKey}/Follower/{userId}", configuration.base_path, userId=p_user_id, appKey=crate::apis::urlencode(p_app_key));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BooleanApiResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BooleanApiResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UserFollowUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 根据粉丝ID更新粉丝信息
pub async fn user_follower_put(configuration: &configuration::Configuration, id: i64, app_key: &str, follower_put_model: Option<models::FollowerPutModel>) -> Result<models::BooleanApiResponse, Error<UserFollowerPutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_app_key = app_key;
    let p_follower_put_model = follower_put_model;

    let uri_str = format!("{}/UserFriends/{appKey}/Follower/{id}", configuration.base_path, id=p_id, appKey=crate::apis::urlencode(p_app_key));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_follower_put_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BooleanApiResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BooleanApiResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UserFollowerPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 根据条件获取我的粉丝列表
pub async fn user_followers(configuration: &configuration::Configuration, app_key: &str, tag: Option<&str>, status: Option<&str>, target_user_id: Option<i64>, skip: Option<i32>, take: Option<i32>) -> Result<models::UserFollowersResultApiResponse, Error<UserFollowersError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_app_key = app_key;
    let p_tag = tag;
    let p_status = status;
    let p_target_user_id = target_user_id;
    let p_skip = skip;
    let p_take = take;

    let uri_str = format!("{}/UserFriends/{appKey}/Followers", configuration.base_path, appKey=crate::apis::urlencode(p_app_key));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_tag {
        req_builder = req_builder.query(&[("tag", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_status {
        req_builder = req_builder.query(&[("status", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_target_user_id {
        req_builder = req_builder.query(&[("targetUserId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_skip {
        req_builder = req_builder.query(&[("skip", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_take {
        req_builder = req_builder.query(&[("take", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UserFollowersResultApiResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UserFollowersResultApiResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UserFollowersError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 根据条件获取我的关注列表，或判断是否关注某个用户
pub async fn user_following(configuration: &configuration::Configuration, app_key: &str, tag: Option<&str>, status: Option<&str>, target_user_id: Option<i64>, skip: Option<i32>, take: Option<i32>, check_user_id: Option<i64>, only_ids: Option<bool>) -> Result<models::BooleanApiResponse, Error<UserFollowingError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_app_key = app_key;
    let p_tag = tag;
    let p_status = status;
    let p_target_user_id = target_user_id;
    let p_skip = skip;
    let p_take = take;
    let p_check_user_id = check_user_id;
    let p_only_ids = only_ids;

    let uri_str = format!("{}/UserFriends/{appKey}/Following", configuration.base_path, appKey=crate::apis::urlencode(p_app_key));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_tag {
        req_builder = req_builder.query(&[("tag", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_status {
        req_builder = req_builder.query(&[("status", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_target_user_id {
        req_builder = req_builder.query(&[("targetUserId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_skip {
        req_builder = req_builder.query(&[("skip", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_take {
        req_builder = req_builder.query(&[("take", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_check_user_id {
        req_builder = req_builder.query(&[("checkUserId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_only_ids {
        req_builder = req_builder.query(&[("onlyIDs", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BooleanApiResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BooleanApiResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UserFollowingError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 根据地理位置坐标和多种筛选条件，查询附近满足条件的用户列表，支持分页和按距离排序。 地理位置查询使用MySQL的ST_Distance_Sphere函数计算球面距离。 注意：longitude为经度(X轴)，latitude为纬度(Y轴)，参数顺序与常规坐标系一致
pub async fn user_friends_near_by(configuration: &configuration::Configuration, longitude: f64, latitude: f64, app_key: &str, country: Option<&str>, state: Option<&str>, city: Option<&str>, district: Option<&str>, gender: Option<&str>, age_s: Option<i32>, age_e: Option<i32>, tag: Option<&str>, distance: Option<i64>, skip: Option<i32>, take: Option<i32>) -> Result<models::UserFriendsNearByResultApiResponse, Error<UserFriendsNearByError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_longitude = longitude;
    let p_latitude = latitude;
    let p_app_key = app_key;
    let p_country = country;
    let p_state = state;
    let p_city = city;
    let p_district = district;
    let p_gender = gender;
    let p_age_s = age_s;
    let p_age_e = age_e;
    let p_tag = tag;
    let p_distance = distance;
    let p_skip = skip;
    let p_take = take;

    let uri_str = format!("{}/UserFriends/{appKey}/NearBy", configuration.base_path, appKey=crate::apis::urlencode(p_app_key));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("longitude", &p_longitude.to_string())]);
    req_builder = req_builder.query(&[("latitude", &p_latitude.to_string())]);
    if let Some(ref param_value) = p_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_state {
        req_builder = req_builder.query(&[("state", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_city {
        req_builder = req_builder.query(&[("city", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_district {
        req_builder = req_builder.query(&[("district", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_gender {
        req_builder = req_builder.query(&[("gender", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_age_s {
        req_builder = req_builder.query(&[("ageS", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_age_e {
        req_builder = req_builder.query(&[("ageE", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_tag {
        req_builder = req_builder.query(&[("tag", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_distance {
        req_builder = req_builder.query(&[("distance", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_skip {
        req_builder = req_builder.query(&[("skip", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_take {
        req_builder = req_builder.query(&[("take", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UserFriendsNearByResultApiResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UserFriendsNearByResultApiResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UserFriendsNearByError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 推荐有共同粉丝的用户
pub async fn user_mutual_followers(configuration: &configuration::Configuration, app_key: &str, skip: Option<i32>, take: Option<i32>) -> Result<models::UserMutualFollowersResultApiResponse, Error<UserMutualFollowersError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_app_key = app_key;
    let p_skip = skip;
    let p_take = take;

    let uri_str = format!("{}/UserFriends/{appKey}/MutualFollowers", configuration.base_path, appKey=crate::apis::urlencode(p_app_key));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_skip {
        req_builder = req_builder.query(&[("skip", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_take {
        req_builder = req_builder.query(&[("take", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UserMutualFollowersResultApiResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UserMutualFollowersResultApiResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UserMutualFollowersError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 推荐有共同关注的用户
pub async fn user_mutual_followings(configuration: &configuration::Configuration, app_key: &str, skip: Option<i32>, take: Option<i32>) -> Result<models::UserMutualFollowingsResultApiResponse, Error<UserMutualFollowingsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_app_key = app_key;
    let p_skip = skip;
    let p_take = take;

    let uri_str = format!("{}/UserFriends/{appKey}/MutualFollowings", configuration.base_path, appKey=crate::apis::urlencode(p_app_key));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_skip {
        req_builder = req_builder.query(&[("skip", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_take {
        req_builder = req_builder.query(&[("take", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UserMutualFollowingsResultApiResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UserMutualFollowingsResultApiResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UserMutualFollowingsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 用于他人主页展示
pub async fn user_profile_by_id(configuration: &configuration::Configuration, user_id: i64, app_key: &str) -> Result<models::GetUserProfileResultApiResponse, Error<UserProfileByIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_user_id = user_id;
    let p_app_key = app_key;

    let uri_str = format!("{}/UserFriends/{appKey}/Profile/{userId}", configuration.base_path, userId=p_user_id, appKey=crate::apis::urlencode(p_app_key));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetUserProfileResultApiResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetUserProfileResultApiResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UserProfileByIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 取消关注指定用户
pub async fn user_unfollow_user(configuration: &configuration::Configuration, user_id: i64, app_key: &str) -> Result<models::BooleanApiResponse, Error<UserUnfollowUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_user_id = user_id;
    let p_app_key = app_key;

    let uri_str = format!("{}/UserFriends/{appKey}/Follower/{userId}", configuration.base_path, userId=p_user_id, appKey=crate::apis::urlencode(p_app_key));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BooleanApiResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BooleanApiResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UserUnfollowUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

