/*
 * 用户全部 API 文档
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`storage_aggregate`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StorageAggregateError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`storage_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StorageDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`storage_detail`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StorageDetailError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`storage_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StorageListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`storage_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StoragePostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`storage_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StoragePutError {
    UnknownValue(serde_json::Value),
}


/// 根据聚合管道查询指定表中的数据
pub async fn storage_aggregate(configuration: &configuration::Configuration, table: &str, app_key: &str, pipeline: Option<&str>) -> Result<models::ObjectListApiResponse, Error<StorageAggregateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_table = table;
    let p_app_key = app_key;
    let p_pipeline = pipeline;

    let uri_str = format!("{}/Storage/{appKey}/{table}/Aggregate", configuration.base_path, table=crate::apis::urlencode(p_table), appKey=crate::apis::urlencode(p_app_key));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_pipeline {
        req_builder = req_builder.query(&[("pipeline", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ObjectListApiResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ObjectListApiResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StorageAggregateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 删除指定表中指定ID的数据
pub async fn storage_delete(configuration: &configuration::Configuration, table: &str, id: &str, app_key: &str) -> Result<models::BooleanApiResponse, Error<StorageDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_table = table;
    let p_id = id;
    let p_app_key = app_key;

    let uri_str = format!("{}/Storage/{appKey}/{table}/{id}", configuration.base_path, table=crate::apis::urlencode(p_table), id=crate::apis::urlencode(p_id), appKey=crate::apis::urlencode(p_app_key));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BooleanApiResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BooleanApiResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StorageDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 获取指定表中指定ID的数据详情
pub async fn storage_detail(configuration: &configuration::Configuration, table: &str, id: &str, app_key: &str, project: Option<&str>) -> Result<models::ObjectApiResponse, Error<StorageDetailError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_table = table;
    let p_id = id;
    let p_app_key = app_key;
    let p_project = project;

    let uri_str = format!("{}/Storage/{appKey}/{table}/{id}", configuration.base_path, table=crate::apis::urlencode(p_table), id=crate::apis::urlencode(p_id), appKey=crate::apis::urlencode(p_app_key));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_project {
        req_builder = req_builder.query(&[("project", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ObjectApiResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ObjectApiResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StorageDetailError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 根据条件查询指定表中的数据
pub async fn storage_list(configuration: &configuration::Configuration, table: &str, app_key: &str, filter: Option<&str>, project: Option<&str>, sort: Option<&str>, start_time: Option<String>, end_time: Option<String>, explain: Option<bool>, take: Option<i32>, skip: Option<i32>) -> Result<models::StorageListResultApiResponse, Error<StorageListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_table = table;
    let p_app_key = app_key;
    let p_filter = filter;
    let p_project = project;
    let p_sort = sort;
    let p_start_time = start_time;
    let p_end_time = end_time;
    let p_explain = explain;
    let p_take = take;
    let p_skip = skip;

    let uri_str = format!("{}/Storage/{appKey}/{table}", configuration.base_path, table=crate::apis::urlencode(p_table), appKey=crate::apis::urlencode(p_app_key));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_filter {
        req_builder = req_builder.query(&[("filter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_project {
        req_builder = req_builder.query(&[("project", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_sort {
        req_builder = req_builder.query(&[("sort", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_start_time {
        req_builder = req_builder.query(&[("startTime", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_end_time {
        req_builder = req_builder.query(&[("endTime", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_explain {
        req_builder = req_builder.query(&[("explain", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_take {
        req_builder = req_builder.query(&[("take", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_skip {
        req_builder = req_builder.query(&[("skip", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::StorageListResultApiResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::StorageListResultApiResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StorageListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 向指定表中添加数据，可以是单个json对象或json数组
pub async fn storage_post(configuration: &configuration::Configuration, table: &str, app_key: &str, request_body: Vec<serde_json::Value>) -> Result<models::StringApiResponse, Error<StoragePostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_table = table;
    let p_app_key = app_key;
    let p_request_body = request_body;

    let uri_str = format!("{}/Storage/{appKey}/{table}", configuration.base_path, table=crate::apis::urlencode(p_table), appKey=crate::apis::urlencode(p_app_key));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_request_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::StringApiResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::StringApiResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StoragePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 更新指定表中指定ID的数据，可以选择全量更新或部分更新
pub async fn storage_put(configuration: &configuration::Configuration, table: &str, id: &str, app_key: &str, request_body: Vec<serde_json::Value>, replace: Option<bool>) -> Result<models::BooleanApiResponse, Error<StoragePutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_table = table;
    let p_id = id;
    let p_app_key = app_key;
    let p_request_body = request_body;
    let p_replace = replace;

    let uri_str = format!("{}/Storage/{appKey}/{table}/{id}", configuration.base_path, table=crate::apis::urlencode(p_table), id=crate::apis::urlencode(p_id), appKey=crate::apis::urlencode(p_app_key));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref param_value) = p_replace {
        req_builder = req_builder.query(&[("replace", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_request_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BooleanApiResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BooleanApiResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StoragePutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

