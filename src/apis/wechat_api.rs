/*
 * 用户全部 API 文档
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`confirm_qr_code_login`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConfirmQrCodeLoginError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`confirm_qr_code_registration`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConfirmQrCodeRegistrationError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`initiate_qr_auth_session`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum InitiateQrAuthSessionError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`scan_qr_code_for_auth`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ScanQrCodeForAuthError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`wechat_decrypt`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WechatDecryptError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`wechat_generate_scheme`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WechatGenerateSchemeError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`wechat_js_code2_session`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WechatJsCode2SessionError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`wechat_js_config`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WechatJsConfigError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`wechat_msg_sec_check`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WechatMsgSecCheckError {
    Status400(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`wechat_subscribe_msg`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WechatSubscribeMsgError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`wechat_subscribe_send`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WechatSubscribeSendError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`wechat_url_link_generate`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WechatUrlLinkGenerateError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`wechat_user_info`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WechatUserInfoError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`wechat_wxa_code_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WechatWxaCodeGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`wechat_wxa_code_get_unlimited`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WechatWxaCodeGetUnlimitedError {
    Status400(),
    UnknownValue(serde_json::Value),
}


/// 微信小程序用户确认二维码登录并获取访问令牌
pub async fn confirm_qr_code_login(configuration: &configuration::Configuration, app_key: &str, qr_code_sign_in_request: Option<models::QrCodeSignInRequest>) -> Result<models::TokenModelApiResponse, Error<ConfirmQrCodeLoginError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_app_key = app_key;
    let p_qr_code_sign_in_request = qr_code_sign_in_request;

    let uri_str = format!("{}/Wechat/{appKey}/QR-Auth/Confirm-Login", configuration.base_path, appKey=crate::apis::urlencode(p_app_key));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_qr_code_sign_in_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TokenModelApiResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TokenModelApiResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ConfirmQrCodeLoginError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 微信小程序用户通过二维码完成注册并获取访问令牌
pub async fn confirm_qr_code_registration(configuration: &configuration::Configuration, app_key: &str, qr_code_sign_up_request: Option<models::QrCodeSignUpRequest>) -> Result<models::TokenModelApiResponse, Error<ConfirmQrCodeRegistrationError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_app_key = app_key;
    let p_qr_code_sign_up_request = qr_code_sign_up_request;

    let uri_str = format!("{}/Wechat/{appKey}/QR-Auth/Confirm-Register", configuration.base_path, appKey=crate::apis::urlencode(p_app_key));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_qr_code_sign_up_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TokenModelApiResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TokenModelApiResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ConfirmQrCodeRegistrationError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 创建用于微信小程序扫码登录/注册的认证会话
pub async fn initiate_qr_auth_session(configuration: &configuration::Configuration, app_key: &str, qr_code_pre_sign_in_request: Option<models::QrCodePreSignInRequest>) -> Result<models::Int64ApiResponse, Error<InitiateQrAuthSessionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_app_key = app_key;
    let p_qr_code_pre_sign_in_request = qr_code_pre_sign_in_request;

    let uri_str = format!("{}/Wechat/{appKey}/QR-Auth/Initiate", configuration.base_path, appKey=crate::apis::urlencode(p_app_key));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_qr_code_pre_sign_in_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Int64ApiResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Int64ApiResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<InitiateQrAuthSessionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 微信小程序扫描二维码并获取应用授权信息
pub async fn scan_qr_code_for_auth(configuration: &configuration::Configuration, app_key: &str, qr_code_scan_request: Option<models::QrCodeScanRequest>) -> Result<models::UserQrCodeScanResultApiResponse, Error<ScanQrCodeForAuthError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_app_key = app_key;
    let p_qr_code_scan_request = qr_code_scan_request;

    let uri_str = format!("{}/Wechat/{appKey}/QR-Auth/Scan", configuration.base_path, appKey=crate::apis::urlencode(p_app_key));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_qr_code_scan_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UserQrCodeScanResultApiResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UserQrCodeScanResultApiResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ScanQrCodeForAuthError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 解密小程序加密数据
pub async fn wechat_decrypt(configuration: &configuration::Configuration, app_key: &str, encrypted_data: Option<&str>, iv: Option<&str>, session_key: Option<&str>) -> Result<models::StringApiResponse, Error<WechatDecryptError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_app_key = app_key;
    let p_encrypted_data = encrypted_data;
    let p_iv = iv;
    let p_session_key = session_key;

    let uri_str = format!("{}/Wechat/{appKey}/Decrypt", configuration.base_path, appKey=crate::apis::urlencode(p_app_key));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_encrypted_data {
        req_builder = req_builder.query(&[("encryptedData", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_iv {
        req_builder = req_builder.query(&[("iv", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_session_key {
        req_builder = req_builder.query(&[("sessionKey", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::StringApiResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::StringApiResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<WechatDecryptError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 生成小程序的scheme码
pub async fn wechat_generate_scheme(configuration: &configuration::Configuration, app_key: &str, request_body: Option<Vec<serde_json::Value>>) -> Result<models::StringApiResponse, Error<WechatGenerateSchemeError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_app_key = app_key;
    let p_request_body = request_body;

    let uri_str = format!("{}/Wechat/{appKey}/GenerateScheme", configuration.base_path, appKey=crate::apis::urlencode(p_app_key));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_request_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::StringApiResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::StringApiResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<WechatGenerateSchemeError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 校验小程序登录凭证
pub async fn wechat_js_code2_session(configuration: &configuration::Configuration, app_key: &str, js_code: Option<&str>) -> Result<models::StringApiResponse, Error<WechatJsCode2SessionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_app_key = app_key;
    let p_js_code = js_code;

    let uri_str = format!("{}/Wechat/{appKey}/JSCode2Session", configuration.base_path, appKey=crate::apis::urlencode(p_app_key));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_js_code {
        req_builder = req_builder.query(&[("js_code", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::StringApiResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::StringApiResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<WechatJsCode2SessionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 获取公众号H5的JS SDK配置
pub async fn wechat_js_config(configuration: &configuration::Configuration, app_key: &str, url: Option<&str>) -> Result<models::WechatJsConfigResultApiResponse, Error<WechatJsConfigError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_app_key = app_key;
    let p_url = url;

    let uri_str = format!("{}/Wechat/{appKey}/JSConfig", configuration.base_path, appKey=crate::apis::urlencode(p_app_key));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_url {
        req_builder = req_builder.query(&[("url", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::WechatJsConfigResultApiResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::WechatJsConfigResultApiResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<WechatJsConfigError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 检测消息内容是否含有违法违规信息
pub async fn wechat_msg_sec_check(configuration: &configuration::Configuration, app_key: &str, request_body: Option<Vec<serde_json::Value>>) -> Result<serde_json::Value, Error<WechatMsgSecCheckError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_app_key = app_key;
    let p_request_body = request_body;

    let uri_str = format!("{}/Wechat/{appKey}/MsgSecCheck", configuration.base_path, appKey=crate::apis::urlencode(p_app_key));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_request_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<WechatMsgSecCheckError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 发送公众号H5一次性订阅消息
pub async fn wechat_subscribe_msg(configuration: &configuration::Configuration, app_key: &str, request_body: Option<Vec<serde_json::Value>>) -> Result<models::StringApiResponse, Error<WechatSubscribeMsgError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_app_key = app_key;
    let p_request_body = request_body;

    let uri_str = format!("{}/Wechat/{appKey}/SubscribeMSG", configuration.base_path, appKey=crate::apis::urlencode(p_app_key));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_request_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::StringApiResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::StringApiResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<WechatSubscribeMsgError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 发送小程序订阅消息
pub async fn wechat_subscribe_send(configuration: &configuration::Configuration, app_key: &str, request_body: Option<Vec<serde_json::Value>>) -> Result<models::StringApiResponse, Error<WechatSubscribeSendError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_app_key = app_key;
    let p_request_body = request_body;

    let uri_str = format!("{}/Wechat/{appKey}/SubscribeSend", configuration.base_path, appKey=crate::apis::urlencode(p_app_key));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_request_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::StringApiResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::StringApiResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<WechatSubscribeSendError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 生成小程序的网页跳转地址
pub async fn wechat_url_link_generate(configuration: &configuration::Configuration, app_key: &str, request_body: Option<Vec<serde_json::Value>>) -> Result<models::StringApiResponse, Error<WechatUrlLinkGenerateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_app_key = app_key;
    let p_request_body = request_body;

    let uri_str = format!("{}/Wechat/{appKey}/UrlLinkGenerate", configuration.base_path, appKey=crate::apis::urlencode(p_app_key));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_request_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::StringApiResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::StringApiResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<WechatUrlLinkGenerateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 获取公众号H5用户的UnionID
pub async fn wechat_user_info(configuration: &configuration::Configuration, app_key: &str, openid: Option<&str>) -> Result<models::StringApiResponse, Error<WechatUserInfoError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_app_key = app_key;
    let p_openid = openid;

    let uri_str = format!("{}/Wechat/{appKey}/UserInfo", configuration.base_path, appKey=crate::apis::urlencode(p_app_key));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_openid {
        req_builder = req_builder.query(&[("openid", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::StringApiResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::StringApiResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<WechatUserInfoError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 获取小程序码
pub async fn wechat_wxa_code_get(configuration: &configuration::Configuration, app_key: &str, request_body: Option<Vec<serde_json::Value>>) -> Result<reqwest::Response, Error<WechatWxaCodeGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_app_key = app_key;
    let p_request_body = request_body;

    let uri_str = format!("{}/Wechat/{appKey}/WXACodeGet", configuration.base_path, appKey=crate::apis::urlencode(p_app_key));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_request_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(resp)
    } else {
        let content = resp.text().await?;
        let entity: Option<WechatWxaCodeGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 获取无限制的小程序码
pub async fn wechat_wxa_code_get_unlimited(configuration: &configuration::Configuration, app_key: &str, request_body: Option<Vec<serde_json::Value>>) -> Result<reqwest::Response, Error<WechatWxaCodeGetUnlimitedError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_app_key = app_key;
    let p_request_body = request_body;

    let uri_str = format!("{}/Wechat/{appKey}/WXACodeGetUnlimited", configuration.base_path, appKey=crate::apis::urlencode(p_app_key));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_request_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(resp)
    } else {
        let content = resp.text().await?;
        let entity: Option<WechatWxaCodeGetUnlimitedError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

