/*
 * 用户全部 API 文档
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`user_deactivate_hard`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UserDeactivateHardError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`user_email_sign_in`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UserEmailSignInError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`user_email_sign_up`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UserEmailSignUpError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`user_phone_sign_in`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UserPhoneSignInError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`user_phone_sign_up`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UserPhoneSignUpError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`user_profile`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UserProfileError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`user_reset_email`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UserResetEmailError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`user_reset_phone`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UserResetPhoneError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`user_reset_pwd`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UserResetPwdError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`user_send_email_code`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UserSendEmailCodeError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`user_send_sms_code`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UserSendSmsCodeError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`user_sign_in`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UserSignInError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`user_sign_up`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UserSignUpError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`user_two_factor_auth`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UserTwoFactorAuthError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`user_union_id_sign_in`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UserUnionIdSignInError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`user_union_id_sign_up`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UserUnionIdSignUpError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`user_update_profile`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UserUpdateProfileError {
    UnknownValue(serde_json::Value),
}


/// 清除用户所有附属数据，并注销账号
pub async fn user_deactivate_hard(configuration: &configuration::Configuration, app_key: &str) -> Result<models::BooleanApiResponse, Error<UserDeactivateHardError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_app_key = app_key;

    let uri_str = format!("{}/User/{appKey}/DeactivateHard", configuration.base_path, appKey=crate::apis::urlencode(p_app_key));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BooleanApiResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BooleanApiResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UserDeactivateHardError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 使用邮箱进行登录
pub async fn user_email_sign_in(configuration: &configuration::Configuration, app_key: &str, email_sign_in_request: Option<models::EmailSignInRequest>) -> Result<models::TokenModelApiResponse, Error<UserEmailSignInError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_app_key = app_key;
    let p_email_sign_in_request = email_sign_in_request;

    let uri_str = format!("{}/User/{appKey}/EmailSignIn", configuration.base_path, appKey=crate::apis::urlencode(p_app_key));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_email_sign_in_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TokenModelApiResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TokenModelApiResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UserEmailSignInError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 使用邮箱进行注册
pub async fn user_email_sign_up(configuration: &configuration::Configuration, app_key: &str, email_sign_up_request: Option<models::EmailSignUpRequest>) -> Result<models::TokenModelApiResponse, Error<UserEmailSignUpError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_app_key = app_key;
    let p_email_sign_up_request = email_sign_up_request;

    let uri_str = format!("{}/User/{appKey}/EmailSignUp", configuration.base_path, appKey=crate::apis::urlencode(p_app_key));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_email_sign_up_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TokenModelApiResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TokenModelApiResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UserEmailSignUpError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 使用手机号码进行登录
pub async fn user_phone_sign_in(configuration: &configuration::Configuration, app_key: &str, phone_sign_in_request: Option<models::PhoneSignInRequest>) -> Result<models::TokenModelApiResponse, Error<UserPhoneSignInError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_app_key = app_key;
    let p_phone_sign_in_request = phone_sign_in_request;

    let uri_str = format!("{}/User/{appKey}/PhoneSignIn", configuration.base_path, appKey=crate::apis::urlencode(p_app_key));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_phone_sign_in_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TokenModelApiResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TokenModelApiResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UserPhoneSignInError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 使用手机号码进行注册
pub async fn user_phone_sign_up(configuration: &configuration::Configuration, app_key: &str, phone_sign_up_request: Option<models::PhoneSignUpRequest>) -> Result<models::TokenModelApiResponse, Error<UserPhoneSignUpError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_app_key = app_key;
    let p_phone_sign_up_request = phone_sign_up_request;

    let uri_str = format!("{}/User/{appKey}/PhoneSignUp", configuration.base_path, appKey=crate::apis::urlencode(p_app_key));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_phone_sign_up_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TokenModelApiResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TokenModelApiResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UserPhoneSignUpError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 获取当前用户的个人资料
pub async fn user_profile(configuration: &configuration::Configuration, app_key: &str) -> Result<models::UserProfileResultApiResponse, Error<UserProfileError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_app_key = app_key;

    let uri_str = format!("{}/User/{appKey}/Profile", configuration.base_path, appKey=crate::apis::urlencode(p_app_key));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UserProfileResultApiResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UserProfileResultApiResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UserProfileError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 通过邮箱验证码重置邮箱
pub async fn user_reset_email(configuration: &configuration::Configuration, app_key: &str, app_user_reset_email_request: Option<models::AppUserResetEmailRequest>) -> Result<models::BooleanApiResponse, Error<UserResetEmailError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_app_key = app_key;
    let p_app_user_reset_email_request = app_user_reset_email_request;

    let uri_str = format!("{}/User/{appKey}/ResetEmail", configuration.base_path, appKey=crate::apis::urlencode(p_app_key));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_app_user_reset_email_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BooleanApiResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BooleanApiResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UserResetEmailError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 通过手机号验证码重置手机号
pub async fn user_reset_phone(configuration: &configuration::Configuration, app_key: &str, app_user_reset_phone_request: Option<models::AppUserResetPhoneRequest>) -> Result<models::BooleanApiResponse, Error<UserResetPhoneError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_app_key = app_key;
    let p_app_user_reset_phone_request = app_user_reset_phone_request;

    let uri_str = format!("{}/User/{appKey}/ResetPhone", configuration.base_path, appKey=crate::apis::urlencode(p_app_key));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_app_user_reset_phone_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BooleanApiResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BooleanApiResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UserResetPhoneError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 通过手机号或邮箱重置密码
pub async fn user_reset_pwd(configuration: &configuration::Configuration, app_key: &str, app_user_reset_pwd_request: Option<models::AppUserResetPwdRequest>) -> Result<models::BooleanApiResponse, Error<UserResetPwdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_app_key = app_key;
    let p_app_user_reset_pwd_request = app_user_reset_pwd_request;

    let uri_str = format!("{}/User/{appKey}/ResetPwd", configuration.base_path, appKey=crate::apis::urlencode(p_app_key));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_app_user_reset_pwd_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BooleanApiResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BooleanApiResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UserResetPwdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 发送邮箱验证码用于注册或找回密码
pub async fn user_send_email_code(configuration: &configuration::Configuration, app_key: &str, send_email_code_request: Option<models::SendEmailCodeRequest>) -> Result<models::BooleanApiResponse, Error<UserSendEmailCodeError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_app_key = app_key;
    let p_send_email_code_request = send_email_code_request;

    let uri_str = format!("{}/User/{appKey}/SendEmailCode", configuration.base_path, appKey=crate::apis::urlencode(p_app_key));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_send_email_code_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BooleanApiResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BooleanApiResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UserSendEmailCodeError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 发送手机验证码用于注册或找回密码
pub async fn user_send_sms_code(configuration: &configuration::Configuration, app_key: &str, send_sms_code_request: Option<models::SendSmsCodeRequest>) -> Result<models::BooleanApiResponse, Error<UserSendSmsCodeError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_app_key = app_key;
    let p_send_sms_code_request = send_sms_code_request;

    let uri_str = format!("{}/User/{appKey}/SendSMSCode", configuration.base_path, appKey=crate::apis::urlencode(p_app_key));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_send_sms_code_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BooleanApiResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BooleanApiResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UserSendSmsCodeError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 使用账号密码进行登录
pub async fn user_sign_in(configuration: &configuration::Configuration, app_key: &str, sign_in_request: Option<models::SignInRequest>) -> Result<models::TokenModelApiResponse, Error<UserSignInError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_app_key = app_key;
    let p_sign_in_request = sign_in_request;

    let uri_str = format!("{}/User/{appKey}/SignIn", configuration.base_path, appKey=crate::apis::urlencode(p_app_key));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_sign_in_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TokenModelApiResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TokenModelApiResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UserSignInError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 使用账号密码进行注册
pub async fn user_sign_up(configuration: &configuration::Configuration, app_key: &str, sign_up_request: Option<models::SignUpRequest>) -> Result<models::TokenModelApiResponse, Error<UserSignUpError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_app_key = app_key;
    let p_sign_up_request = sign_up_request;

    let uri_str = format!("{}/User/{appKey}/SignUp", configuration.base_path, appKey=crate::apis::urlencode(p_app_key));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_sign_up_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TokenModelApiResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TokenModelApiResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UserSignUpError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 获取当前用户在指定应用下启用二次验证（2FA）所需的设置信息，主要包括二维码链接和手动密钥，用户可以将其录入在 Google Authenticator 等 TOTP 应用中，用于后续动态验证码验证。
pub async fn user_two_factor_auth(configuration: &configuration::Configuration, app_key: &str) -> Result<models::SetupCodeApiResponse, Error<UserTwoFactorAuthError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_app_key = app_key;

    let uri_str = format!("{}/User/{appKey}/TwoFactorAuth", configuration.base_path, appKey=crate::apis::urlencode(p_app_key));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SetupCodeApiResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SetupCodeApiResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UserTwoFactorAuthError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 使用UnionID进行登录
pub async fn user_union_id_sign_in(configuration: &configuration::Configuration, app_key: &str, union_id_sign_in_request: Option<models::UnionIdSignInRequest>) -> Result<models::TokenModelApiResponse, Error<UserUnionIdSignInError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_app_key = app_key;
    let p_union_id_sign_in_request = union_id_sign_in_request;

    let uri_str = format!("{}/User/{appKey}/UnionIDSignIn", configuration.base_path, appKey=crate::apis::urlencode(p_app_key));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_union_id_sign_in_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TokenModelApiResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TokenModelApiResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UserUnionIdSignInError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 使用UnionID进行注册
pub async fn user_union_id_sign_up(configuration: &configuration::Configuration, app_key: &str, union_id_sign_up_request: Option<models::UnionIdSignUpRequest>) -> Result<models::TokenModelApiResponse, Error<UserUnionIdSignUpError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_app_key = app_key;
    let p_union_id_sign_up_request = union_id_sign_up_request;

    let uri_str = format!("{}/User/{appKey}/UnionIDSignUp", configuration.base_path, appKey=crate::apis::urlencode(p_app_key));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_union_id_sign_up_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TokenModelApiResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TokenModelApiResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UserUnionIdSignUpError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 更新当前用户的个人资料
pub async fn user_update_profile(configuration: &configuration::Configuration, app_key: &str, update_profile_request: Option<models::UpdateProfileRequest>) -> Result<models::BooleanApiResponse, Error<UserUpdateProfileError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_app_key = app_key;
    let p_update_profile_request = update_profile_request;

    let uri_str = format!("{}/User/{appKey}/Profile", configuration.base_path, appKey=crate::apis::urlencode(p_app_key));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_update_profile_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BooleanApiResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BooleanApiResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UserUpdateProfileError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

